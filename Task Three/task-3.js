//Task 3: Game Requirements Programming

// SECTION Design and apply a data structure to represent the game board and mines
function initGridObj(gridSize) {
    const gridObjMatrix = []; 

    for (let rowIndex = 0; rowIndex < gridSize; rowIndex++) { 
        // Loop through each row while rowIndex is less then or equal to grid size

        const row = []; 
        //  generating an array or list for each row to add tile object

        for (let colIndex = 0; colIndex < gridSize; colIndex++) { 
            // Loop through each column while colIndex is less then or equal to grid size

            let tileObj = { 
                // for each column create an object which stores the current tiles properties bellow

                isMine: false, // set all tiles to false initially and will be changed in a function that adds the mines
                visibility: "hidden", // optional property ive added for readability later in the code.
                char: "-", // the default character which will be changed after the user selects their input.
            };

            row.push(tileObj); 
            // add each column to the row
        }
        gridObjMatrix.push(row);
        // add each row generated by the for loop to the array I initialized on line 5
    }
    return gridObjMatrix; 
    // return the array for other functions to use
}

//SECTION Implement a user input using the command line interface to display the game board and accept user input. (game board)
let displayGrid = (gridObj)=>{
    // this is an anonymous function assigned to a variable which will later call it

    console.table(gridObj.map((row) => row.map((tileObj) => tileObj.char))); 
    // The first map iterates over each row of the grid
    // for each row map function is called again to iterate over the columns to get each tile object (tileObj)
    // for each tileObj it then retrieves the .char property which will represent that object on the grid
    // the first map function then returns an 2D array like our gridObj but only of the .char properties.
    // Console.table then displays the grid.
}

// SECTION Implement a function to randomly place mines on the board.
function assignMines(startX, startY, gridObj, numberOfMines) { 
    // takes in the starting coords, grid object returned from above, and amount of mines selected from the level

    let randomGridObj,x,y;
    // create an a variable to so store our X,Y variables so they're assessable in the function scope, random obj which will be a reference to a grid object

    for (let i = 0; i < numberOfMines; i++) {
        // loop though the amount of mines to assign, because the i index is starting at 0 and our mine count doesn't, 
        // we need to use the < less then. if mine count was 3 the the i will iterate 0, 1, 2 times which is 3 times

        do {
            // do while loop will execute until the random obj is not already a mine or the starting coordinate.
            // this addresses the instant death bug.

            x = Math.floor(Math.random() * gridObj.length); 
            y = Math.floor(Math.random() * gridObj[0].length); 
            // y axis being GridObj[0].length enures rows and col both get the accurate length.
            // though they're the same length theres potential for a bug if somehow they're not.
            
            // math.floor rounds to the nearest whole number 0 or 1, 
            // math.random generates a float from 0 to 1, number between 0 - object length.
            
            randomGridObj = gridObj[x][y]; 
            // reference to grid object (not a copy), so we can update the properties of the gridObj bellow.

        } while ( 
            //The loop continues if the statement bellow is true
            randomGridObj.isMine || (x === startX && y === startY)
        );
        
        //outside of the do while loop
        // when the randomGridObj is not a mine or starting position it will change the properties of the randomGridObj
        // which therefore change the gridObj as its a reference 

        randomGridObj.isMine = true; // Change this to a boolean
        randomGridObj.char = "X"; // FIXME testing turn this off if you want to play properly

        }
    }

function handleInput(string,boardSize) {
    // string will represent the user input from prompt, board size comes from another function called level added into the final version

    let userInput = string
    .split(/\s*,\s*/) // uses Regex to split at commas and remove whitespace around them and return an array
    .map((item)=>{ // .map iterates over the array, for each item and will change the item based on the condition bellow
        return isNaN(item) ? item : parseInt(item);
        // uses a turnery operator to compare if the sting item is a NaN (not an Integer), 
        // if the string contains an integer it will convert it using parseInt
    });
    
    let validInput = []; // initializing an empty array to store the new value bellow otherwise its unaccessible out of the switch block

    switch (boardSize) {
        // this is not particularly reusable code but due to only having few levels I chose to do it like to save time

        case 3: // if the board size 3 x 3 bellow are the valid inputs
            validInput = [0, 1, 2, "O", "F", "?"];
            break;
        case 16: // if the board size 16 x 16 bellow are the valid inputs
            validInput = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, "O", "F", "?"];
            break;
        default: // the default ensures if the input is invalid you still get a result
            validInput = [0, 1, 2, 3, 4, 5, 6, 7,8, "O", "F", "?"];
            break;
    }

        while (!validInput.includes(userInput[0]) || !validInput.includes(userInput[1]) || !validInput.includes(userInput[2])) {
            // in english this says while validInput not including userInput and its first index and the same sor all the other indexes

            newInput = prompt("Invalid input. Please enter coordinates (X, Y) and action (O, F, ?) in the format: X, Y, O/F/? (e.g., 1,1,O)");
            // get a valid input from the user until its correct
            
            userInput = newInput.split(/\s*,\s*/).map((item)=>{ 
                return isNaN(item) ? item : parseInt(item);
            }); // use the same method as above to remove space and commas, then map the items that contain integers and change the item based on the condition
            
        }


    // shows user their input location
        
    console.log(`board size 3 x 3`);// tells the user their grid choice
    console.log("Your X input:",userInput[0],"Your Y input:",userInput[1],"Your action:",userInput[2]);
    
    return userInput; // returns an array of the user input
}

//SECTION Implement a function to flag cells suspected of containing mines
function tileState(gridObj, x, y, action) {
    const tileObj = gridObj[x][y];
    // assign the current tile chosen using the x, y values from the user input

    if (action === "O") {
        // if the action is to open the cell we call the following functions:
    
        checkLossConditions(tileObj, gridObj);
        adjacentMineHandler(gridObj, x, y, tileObj);

        // because its here it overwrites the chars of the flagged or questioned tiles and 
        // displays a number like 0 with the adjacentMineHandler function as its recursive 
        
        // There a small bug/feature you the user can assign flags to open cells I haven't addressed in this code bellow
    } else if (action === "F") {
        // check if the action is === "F" for fag

        if(tileObj.visibility === "flag" ){  
            // check if the tile is currently flagged
            // don't need to use viability here but i used it for readability 

            tileObj.visibility = "hidden"
            tileObj.char = '-'
            // set the tile back to default

        }else{
            // if it hasn't been flagged then flag it
            tileObj.visibility = "flag";
            tileObj.char = "F";
        }
    } else if (action === "?") {
        // this is the same functionality as above
        if(tileObj.visibility === "question"){
            tileObj.visibility = "hidden";
            tileObj.char = '-';
        }else{
            tileObj.visibility = "question";
            tileObj.char = "?";
        }
    }
    displayGrid(gridObj)
    // this is were this will be called in the game after the grid has updated to display the new info
}

// SECTION Implement a function to calculate the number of mines adjacent to a selected cell.
function adjacentMineHandler(gridObj, x, y, tileObj) {

     //declaring these variables in the local scope
    let adjacentMines = 0;
    const rowLength = gridObj.length;
    let colLength = gridObj[0].length; 

    // checks for adjacent mines by adding the offset to the x,y coords and sees if the surrounding tiles are mines.
    // coords neighboring offsets:
    // 0: (x - 1, y - 1) ,(x - 1, y),(x - 1, y + 1)
    // 1: (x, y - 1), (input : x , y ), (x, y + 1)
    // 2: (x + 1, y - 1),(x + 1, y),(x + 1, y + 1)

    // the offsetX and offsetY refers to how much we need to add or subtract from the users input which we index from
    // eg. if the input is 1,1 in the middle of the 3x3 grid 
    // to get to the top right index which would need to be 0,0
    // mathematically this is how it would work, x -1 = 0, y -1 = 0
    
    // we then use a nested for loop to apply all the off sets -1,0,+1 to each index
    // eg. assuming the input is (1,1)
    //   first row position : 1st(0,0), 2nd (0,1), 3rd (0,2)
    //   second row position : 1st(1,0), 2nd(1,1), 3rd (1,2)
    //   first row potion :   1st:(2,0), 2nd(2,1) , 3rd(2,2)

    // using the nested for loops we can achieve this bellow as the offsetX will run once every time the offsetY completes its loop

    for (let offsetX = -1; offsetX <= 1; offsetX++) {
        // offsetX is -1, it then becomes 0
        // offsetX is 0, it then becomes 1
        // loop is terminated as the offsetX <= 1 is not longer true

        const adjacentX = x + offsetX;
        // assuming x = 1, adjacentX = x + -1 = 0
        
        for (let offsetY = -1; offsetY <= 1; offsetY++) {
            // here we are doing the same offset but for every column but this will run as many times until the offsetY < 1 is met 
            // therefor it will run 3 times -1, 0, 1
            // then go back to the offsetX loop
            
            const adjacentY = y + offsetY; // adding the offset to the current coords

            if ( // check if tile is in boundaries
            adjacentX >= 0 && adjacentX < rowLength && adjacentY >= 0 && adjacentY < colLength
            // this insures that mines will be assigned as long as its an index in bounds or dose not exceed the number of rows
            ) {
                
                const adjacentTile = gridObj[adjacentX][adjacentY]; // adds the value of the adjacentX and Y to the index to get teh adjacent tile
                if (adjacentTile.isMine) { // checks if that tile is a mine
                    adjacentMines++; //  if it is a mine it updates mine counter 
                }
            }
        }
    }

    //SECTION Implement a function to uncover cells and recursively uncover adjacent cells with no adjacent mines.
    if (adjacentMines === 0) {
        // The recursive opening of tiles only applies to cells without adjacent mines so with if statement checks
        // if the current tile object has no adjacent mines.

        tileObj.char = 0; // this updates the number which will represent it on the grid

        for (let offsetX = -1; offsetX <= 1; offsetX++) { // here again we have the exact same for loop with the offset as the code above to calculate the mines
            const adjacentX = x + offsetX;
            for (let offsetY = -1; offsetY <= 1; offsetY++) {
                const adjacentY = y + offsetY;

                if ( adjacentX >= 0 && adjacentX < rowLength && adjacentY >= 0 && adjacentY < colLength ) {
                    // we are also see the same grid boundary condition as above 

                    const adjacentTile = gridObj[adjacentX][adjacentY]; // adding a reference the the grid object with the adjacent coordinates as an index

                    if (adjacentTile.visibility !== "open") {
                        // only open unopened adjacent tiles

                        adjacentTile.visibility = "open";
                        adjacentTile.char = 0;
                        // updating the properties to display the adjacent tile

                        adjacentMineHandler(gridObj, adjacentX, adjacentY, gridObj[adjacentX][adjacentY]); // recursively open adjacent tiles

                        // we call the function again parsing in the adjacentX and adjacentY as our reference point which will then go though the same steps as
                        // the X, Y user input coords creating recursion for all adjacent tiles which have no adjacent mines.
                        // this function dose not stop the for loop until the <= 1 condition is met in the for loop, 
                        // it executes multiple instances of adjacentMineHandler function, for each adjacent tile, and then executes
                        // multiple instances of adjacentMineHandler function again, for each adjacent tile of the adjacent tile and so on 
                        // until the conditions are met stopping it from recurring again.
                    }
                }
            }
        }
    }

    if (adjacentMines > 0) { // if the selected tile has adjacent mines add the number
        tileObj.char = adjacentMines;
        tileObj.visibility = "open";
    }

    checkWinConditions(gridObj)
}

// SECTION Implement a function to check if a selected cell contains a mine
function checkLossConditions(tileObj, gridObj) {
    if (tileObj.isMine === true) { // checks if the opened tile contains a mine
        for (let i = 0; i < gridObj.length; i++) {
            // looping though the row index

            for (let j = 0; j < gridObj[i].length; j++) {
                // looping through the column index

                if (gridObj[i][j].isMine) { // checks if that item contained a mine
                    gridObj[i][j].visibility = "mine"; // change's the visibility 
                    gridObj[i][j].char = "X"; // shows mine to user
                }
            }
        }

        displayGrid(gridObj) // displays the new updated board 

        alert("You hit a mine YOU LOOSE!"); // tells the user they lost
        let restart = prompt("type R to restart or E to exit");
        if (restart.toUpperCase() === "R") {
            startGame(); // restart the game loop for the user to play again 
        } else {
            alert("Thanks for playing!");
            return (gameLoop = false); // turns off the game loop and stops the program
        }
    }
}

// checks if the player has won
function checkWinConditions(gridObj) {
    let numRows = gridObj.length // length of rows
    let numCols = gridObj[0].length // length of columns

    let tilesOpened = 0; // tells us how many cells the user has opened
    let totalMineCount = 0; // count the total on mines on the board


    // calculate tilesOpened and tilesLeft inside the loop
    for (let i = 0; i < numRows; i++) {
        // loop though till number of rows

        for (let j = 0; j < numCols; j++) {
            // loop though till number of columns

            const tile = gridObj[i][j]; 
            // access the properties from every tile

            if (tile.visibility === "open" && !tile.isMine) {
                // if the tile had been opened and that tile is not a mine

                tilesOpened++; // getting the number of tiles opened
            } else if (tile.isMine) {
                totalMineCount++; // getting the number of mines
                // since the number of mines is static we don't really need to do this since we know that number
                // I thought method just as easy as passing in the value
            }
        }
    }

    let tileCount = gridObj.length * gridObj[0].length; // total number of tiles
    let tilesLeft = tileCount - totalMineCount; 
    // total number of tiles - totalMineCount gives us total amount of cells available cells to open on the grid

    if (tilesOpened === tilesLeft) {
        //if the users opened tiles is equal to the amount of available tiles to open 

        for (let i = 0; i < numRows; i++) {
            //loop through rows
            for (let j = 0; j < numCols; j++) {
                // loop though columns

                if (gridObj[i][j].isMine) { // display the mines to the user
                    gridObj[i][j].visibility = "mine";
                    gridObj[i][j].char = "*";
                }
            }
        }
        displayGrid(gridObj) // show the updated board with mine locations

        alert("Congratulations You've WON!"); // tell the user they won 
        let restart = prompt("type R to restart or E to exit"); // ask them to restart 
        if (restart.toUpperCase() === "R") {
            startGame(); // start game if the choose to 
        } else {
            // if they choose to not play then end the game loop
            alert("Thanks for playing!");
            return (gameLoop = false);
        }
    }
}


// selects the level
function level(levelChoice) {
    let numberOfMines, currentLevel, gridSize // initializing multiple variables 

    switch (levelChoice) { 
        //using the switch we can check the level the user has selected in the levelChoice

        case "E":
            // if the user selected E the level will be specified as bellow
            numberOfMines = 3;
            currentLevel = "easy";
            gridSize = 3;
            break;
        case "M":
            // if the user selected M the level will be specified as bellow
            numberOfMines = 20;
            currentLevel = "medium";
            gridSize = 9;
            break;
        case "H":
            // if the user selected H the level will be specified as bellow
            numberOfMines = 40;
            currentLevel = "hard";
            gridSize = 16;
            break;
        default:
            // if the user inputted an invalid input the level will be specified as bellow as a kind of safe measure
            numberOfMines = 40;
            currentLevel = "The hidden level";
            gridSize = 9;
    }
    console.log(`your current difficulty is set to ${currentLevel} with ${numberOfMines} mines and a ${gridSize} x ${gridSize}`);
    // the display to the user there chosen level with the amount of mines

    return [numberOfMines, gridSize]; 
    // return an array of data we can parse into the initGrid function and assign mine function
}


//SECTION Implement a user input using the command line interface to display the game board and accept user input. (user input)
let gameLoop = true;

function startGame() {
    let gridObj = []; 
    // stores the game board so its updated and replaced every time the game starts

    const levelChoice = prompt("Choose your level E : easy | 3x3 3 mines, M: medium | 9x9 10 mines, H : Hard | 16x16 40 mines").toUpperCase();
    // gets user input on level choice and converts it to upper case

    let [numberOfMines, gridSize] = level(levelChoice); 
    // takes the array output of level function and assigns it to the variables using destructuring assignment 

    displayGrid(initGridObj(gridSize));
    // calls the displayGrid for the user to visualize there first move

    let [initInputX,initInputY,initAction] = handleInput(
        prompt("To start the game, please enter coordinates located on the left and top index in the format of: X, Y, O (open), F (flag), or ? (unsure), e.g., 1,1,O"),
        gridSize);
        // takes the array output of handleInput function and assigns it to the variables using destructuring assignment 
        // 

    gridObj = initGridObj(gridSize); 
    // create the grid objects

    assignMines(initInputX, initInputY, gridObj, numberOfMines); 
    // assign mines to those grid objects

    tileState(gridObj, initInputX, initInputY, initAction); 
    // display the tile state from the users initial Input

    while (gameLoop === true) { 
    // after the initial move then we enter the game loop
    //this code will be executed until gameLoop is set to false in the win or loss condition functions

        let [inputX,inputY,action] = handleInput(prompt("Enter coords: X, Y, O F or ?"), gridSize);
        // we get a new input from the user each loop and apply the arr returned to the variables using destructuring assignment 

        tileState(gridObj, inputX, inputY, action);
        //then we call this function to apply the desired functionality to the users tile
    }
}

alert("Welcome to Minesweeper! In this game, you must use your powers of deduction to uncover tiles on the board without revealing hidden mines. Please navigate to your console as the game will beguin in 5 seconds")
setTimeout(startGame,5000); // call the function to start the game