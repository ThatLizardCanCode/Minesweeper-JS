 // SECTION "Requirement 1. generate a game board of 3 x 3 cells." ----------------------------------------------------------------


For this function "initGridObj" it takes in one parameter "gridSize" this will allow us to change the grid and add for a potential level feature. I've chosen to create an object for each item on the grid, This allows me to store and easily access the properties within it for later reference. Furthermore, the char properties is what will determine what tile is displayed as on the grid which is why it's stylized at “-” initially, as it's an empty grid since the user has not made any move. It's not until the mine assignment function later that the property isMine will be turned to true for randomized mines. as for the "visibility" property it was optional but ive added this in for code readability for when comparing tiles in there different state instead of comparing chars.


<script>

    function initGridObj(gridSize) {
        const gridObjMatrix = []; 

        for (let rowIndex = 0; rowIndex < gridSize; rowIndex++) { 
            // Loop through each row while rowIndex is less then or equal to grid size

            const row = []; 
            //  generating an array or list for each row to add tile object to

            for (let colIndex = 0; colIndex < gridSize; colIndex++) { 
                // Loop through each column while colIndex is less then or equal to grid size

                let tileObj = { 
                    // for each column create an object which stores the current tiles properties

                    isMine: false, // set all tiles to false initially and will be changed in a function that adds the mines
                    visibility: "hidden", // optional property ive added for readability later in the code.
                    char: "-", // the default character which will be changed after the user selects their input.
                };

                row.push(tileObj); 
                // add each column to the row
            }
            gridObjMatrix.push(row);
            // add each row generated by the for loop to the array I initialized on line 5
        }
        return gridObjMatrix; 
        // return the array for other functions to use
    }

</script>


This is an anonymous function which is assigned to the variable "displayGrid" which takes the parameter "gridObj" which is returned from the initGridObj function. This type of function is suited to this instance where we want to create a simple function in fewer lines of code. I designed this specifically because it was easier then writing "console.table(gridObj.map((row) => row.map((tileObj) => tileObj.char)));" multiple times, it helps to add readability to the code. Inside this function uses a method of "console" called "console.table", which displays data in a tabular format, the issue with this is that console.table wants to display the the array as a whole, and not the individual properties of each element, therefore we ended up having to use map to iterate over the rows then map it again to map the columns and return an array of only the "tileObj.char" properties. I could have done this differently and manually created a grid but I like the look of the "console.table" format and learned about its usefulness particularly with bug testing and displaying rows of data in a coherent format.


<script>

    let displayGrid = (gridObj)=>{

        console.table(gridObj.map((row) => row.map((tileObj) => tileObj.char)));

        // The first map iterates over each row of the grid
        // for each row map function is called again to iterate over the columns to get each tile object (tileObj)
        // for each tileObj it then retrieves the .char property which will represent that object on the grid
        // the first map function then returns an 2D array like our gridObj but only of the .char properties.
        // Console.table then displays the grid.
    }

</script>


// SECTION Requirement 2. randomly place mines on the board.----------------------------------------------------------------------


This Function takes in the parameters "startX","startY", "gridObj" returned from initGridObj function and "numberOfMines". startX and startY refer to the initial user input coordinates on the first turn so that we can ensure we don't assign a mine to that tile, we can also tell the program how many mines to assign by using the "for" loop by telling it to do an iteration for each "numberOfMines", this can be utilized later to add in a level feature and also to ensure that it doesn't assign a mine to a tile that already contains a mine. To implement this ive utilized a "do while" loop, in this loop the "do" will generate two random coordinates, "x" and "y" and assign this to a "randomGridObj" which is a reference to the "gridObj" but with the randomly generated coordinates within the range of that objects row and column length, "while" that "randomGridObj" is either already a mine or if the "x" row coordinate is equal to the "startX" and "y" column coordinates are equal to the "startY", it will generate a new "randomGridObj". if these new coordinates pass the conditions of the "while" the properties can be updated to "randomGridObj.isMine = True" and will therefor update the "gridObj" to contain a mine. The reason why ive used the "do while" loop is because we can generate coordinates until the condition is met therefore in the off chance it generates the same invalid input multiple times it will reassign it until its valid.


<script>

function assignMines(startX, startY, gridObj, numberOfMines) { 
    // takes in the starting coords, grid object returned from above, and amount of mines selected from the level

    let randomGridObj,x,y;
    // create an a variable to so store our X,Y variables so they're assessable in the function scope, random obj which will be a reference to a grid object

    for (let i = 0; i < numberOfMines; i++) {
        // loop though the amount of mines to assign, because the i index is starting at 0 and our mine count doesn't, 
        // we need to use the < less then. if mine count was 3 the the i will iterate 0, 1, 2 times which is 3 times

        do {
            // do while loop will execute until the random obj is not already a mine or the starting coordinate.
            // this addresses the instant death bug.

            x = Math.floor(Math.random() * gridObj.length); 
            y = Math.floor(Math.random() * gridObj[0].length); 
            // y axis being GridObj[0].length enures rows and col both get the accurate length.
            // though they're the same length theres potential for a bug if somehow they're not.
            
            // math.floor rounds to the nearest whole number 0 or 1, 
            // math.random generates a float from 0 to 1, number between 0 - object length.
            
            randomGridObj = gridObj[x][y]; 
            // reference to grid object (not a copy), so we can update the properties of the gridObj bellow.

        } while ( 
            //The loop continues if the statement bellow is true
            randomGridObj.isMine || (x === startX && y === startY)
        );
        
        //outside of the do while loop
        // when the randomGridObj is not a mine or starting position it will change the properties of the randomGridObj
        // which therefore change the gridObj as its a reference 

        randomGridObj.isMine = true; // Change this to a boolean
        randomGridObj.char = "X"; // Added the Char to X for testing purposes

        }
    }

</script>


// SECTION Requirement 3. The program must allow the user to select cells to uncover ------------------------------------------------------


Here we have the handleInput function which takes in the parameter user input "string" from the prompt, it then applies the formatting from string with white space and commas removed into array called "userInput", it also converts the numbers which are in string format into integers. The "while" loop will keep asking for a valid user input if each index of "userInput" its included in the "validInput" array until this condition is true and reformat and return "newInput", the same as the "string" if it passes the valid input condition.


<script>

    function handleInput(string) {
        // string will represent the user input from prompt, board size comes from another function called level added into the final version

        let userInput = string
        .split(/\s*,\s*/) // uses Regex to split at commas and remove whitespace around them and return an array
        .map((item)=>{ // .map iterates over the array, for each item and will change the item based on the condition bellow
            return isNaN(item) ? item : parseInt(item);
            // uses a turnery operator to compare if the sting item is a NaN (not an Integer), 
            // if the string contains an integer it will convert it using parseInt
        });
        
        validInput = [0, 1, 2, "O", "F", "?"];

        while (!validInput.includes(userInput[0]) || !validInput.includes(userInput[1]) || !validInput.includes(userInput[2])) {
            // in english this says while validInput not including userInput and its 0 index or not including userInput and its 1 index or  not including userInput and its 2 index 

            newInput = prompt("Invalid input. Please enter coordinates (X, Y) and action (O, F, ?) in the format: X, Y, O/F/? (e.g., 1,1,O)");
            // get a valid input from the user until its correct
            
            userInput = newInput.split(/\s*,\s*/).map((item)=>{ 
                return isNaN(item) ? item : parseInt(item);
            }); // use the same method as above to remove space and commas, then map the items that contain integers and change the item based on the condition
            
        }

        // shows user their input location
            
        console.log(`board size 3 x 3`);// tells the user their grid choice
        console.log("Your X input:",userInput[0],"Your Y input:",userInput[1],"Your action:",userInput[2]);
        
        return userInput; // returns an array of the user input
    }

</script>


// SECTION Requirement 4. The program must allow the user to flag cells they suspect contain mines. -------------------------------


This function openTile is relatively straight forward, is takes in the parameters "gridObj", "x", "y" and "action" which refers to what the user wants to do with this tile. its essentially just consists of "if" and "if else" statements to check what the users "action" is and apply the functionality. "if" the user wants to open a tile it will check if they've lost which will stop the game, if not then it will go ahead and call the "adjacentMineHandler" function to open that tile and display mines. "else if" they want to flag a tile and that tile is already flagged it will remove the flag, otherwise or "else" it will flag the tile and update the properties, same goes with the question "action".


<script>

    function openTile(gridObj, x, y, action) {
        const tileObj = gridObj[x][y];
        // assign the current tile chosen using the x, y values from the user input

        if (action === "O") {
            // if the action is to open the cell we call the following functions:
        
            checkLossConditions(tileObj, gridObj);
            adjacentMineHandler(gridObj, x, y, tileObj);

            // because its here it overwrites the chars of the flagged or questioned tiles and 
            // displays a number like 0 with the adjacentMineHandler function as its recursive 
            
            // There a small bug/feature you the user can assign flags to open cells I haven't addressed in this code bellow
        } else if (action === "F") {
            // check if the action is === "F" for fag

            if(tileObj.visibility === "flag" ){  
                // check if the tile is currently flagged
                // don't need to use viability here but i used it for readability 

                tileObj.visibility = "hidden"
                tileObj.char = '-'
                // set the tile back to default

            }else{
                // if it hasn't been flagged then flag it
                tileObj.visibility = "flag";
                tileObj.char = "F";
            }
        } else if (action === "?") {
            // this is the same functionality as above
            if(tileObj.visibility === "question"){
                tileObj.visibility = "hidden";
                tileObj.char = '-';
            }else{
                tileObj.visibility = "question";
                tileObj.char = "?";
            }
        }
        displayGrid(gridObj)
        // this is were this will be called in the game after the grid has updated to display the new info
    }

</script>


// SECTION Requirement 5. The program must provide clues about the number of mines adjacent to a selected cell--------------------


"adjacentMineHandler" function is most complex part of this code, it involves first checking for adjacent mines by nesting two "for loops" and adding the offsets -1, 0, 1 to the "x" in the first "for loop" to get the first row index and add the "y" offset coordinates in the "nested for loop", we can use these adjacent coordinates to create a reference to our "gridObj" like this "adjacentTile = gridObj[adjacentX][adjacentY]", then we check "if" that "adjacentTile" is within the grid barriers and contains a mine then update the "adjacentMines" variable which counts the mines. because javascript counts the length of our rows starting at 1, the length of the row and col would be 3 for a 3x3 grid even though our index starts at 0, this is why we have to ensure "rowLength" and "colLength" are using the "<" and not "<=" to check if the "adjacentTile" is out of bounds. After we have the "adjacentMines" number we can then use an "if" statement to check "if adjacentMines" is greater than 0 we can update the .char properties to display the "adjacentMines" count, otherwise this will be displayed as 0.

<script>

    function adjacentMineHandler(gridObj, x, y, tileObj) {

        //declaring these variables in the local scope
        let adjacentMines = 0;
        const rowLength = gridObj.length; // 3
        let colLength = gridObj[0].length; // 3

        // checks for adjacent mines by adding the offset to the x,y coords and sees if the surrounding tiles are mines.
        // coords neighboring offsets:
        // 0: (x - 1, y - 1) ,(x - 1, y),(x - 1, y + 1)
        // 1: (x, y - 1), (input : x , y ), (x, y + 1)
        // 2: (x + 1, y - 1),(x + 1, y),(x + 1, y + 1)

        // the offsetX and offsetY refers to how much we need to add or subtract from the users input which we index from
        // eg. if the input is 1,1 in the middle of the 3x3 grid 
        // to get to the top right index which would need to be 0,0
        // mathematically this is how it would work, x -1 = 0, y -1 = 0
        
        // we then use a nested for loop to apply all the off sets -1,0,+1 to each index
        // eg. assuming the input is (1,1)
        //   first row position : 1st(0,0), 2nd (0,1), 3rd (0,2)
        //   second row position : 1st(1,0), 2nd(1,1), 3rd (1,2)
        //   first row potion :   1st:(2,0), 2nd(2,1) , 3rd(2,2)

        // using the nested for loops we can achieve this bellow as the offsetX will run once every time the offsetY completes its loop

        for (let offsetX = -1; offsetX <= 1; offsetX++) {
            // offsetX is -1, it then becomes 0
            // offsetX is 0, it then becomes 1
            // loop is terminated as the offsetX <= 1 is not longer true

            const adjacentX = x + offsetX;
            // assuming x = 1, adjacentX = x + -1 = 0
            
            for (let offsetY = -1; offsetY <= 1; offsetY++) {
                // here we are doing the same offset but for every column but this will run as many times until the offsetY < 1 is met 
                // therefor it will run 3 times -1, 0, 1
                // then go back to the offsetX loop
                
                const adjacentY = y + offsetY; // adding the offset to the current coords

                if ( // check if tile is in boundaries
                adjacentX >= 0 && adjacentX < rowLength && adjacentY >= 0 && adjacentY < colLength
                // this insures that mines will be assigned as long as its an index in bounds or dose not exceed the number of rows
                ) {
                    
                    const adjacentTile = gridObj[adjacentX][adjacentY]; // adds the value of the adjacentX and Y to the index to get teh adjacent tile
                    if (adjacentTile.isMine) { // checks if that tile is a mine
                        adjacentMines++; //  if it is a mine it updates mine counter 
                    }
                }
            }
        }

        // recursively opens tiles that have no mines code to be added here

        if (adjacentMines > 0) { // if the selected tile has adjacent mines add the number
            tileObj.char = adjacentMines;
            tileObj.visibility = "open";
        } else{ // otherwise its char will be set to 0
            tileObj.char = 0;
            tileObj.visibility = "open";
        }

        checkWinConditions(gridObj)
    }

</script>



// SECTION Requirement 6. The program must indicate whether a selected cell contains a mine. -------------------------------------


This function checks if the user has hit a mine, "if" the "tileObj" the user has selected has the ".isMine" property set to "true" it will then display all the mines by using "nested loops", to access the row and column of the "gridObj" and then change the properties of those "gridObj", "if" they have the ".isMine" property set "true", then the object properties to to display the 
".char to X". Though the ".visibility" propriety is not necessary as ive added it in for readability, and constancy as we did utilize these properties in the "openTile" function, which was also due to readability.
After the properties has be altered for the tiles containing mines, the function then goes ahead and displays this updated board, tells the user they've lost and prompts them to restart, if they wish to play again the "startGame" function is called once again to restart the game loop.


<script>

    function checkLossConditions(tileObj, gridObj) {
        if (tileObj.isMine === true) { // checks if the opened tile contains a mine
            for (let i = 0; i < gridObj.length; i++) {
                // looping though the row index

                for (let j = 0; j < gridObj[i].length; j++) {
                    // looping through the column index

                    if (gridObj[i][j].isMine) { // checks if that item contained a mine
                        gridObj[i][j].visibility = "mine"; // change's the visibility not really nessacray 
                        gridObj[i][j].char = "X"; // shows mine to user
                    }
                }
            }

            displayGrid(gridObj) // displays the new updated board 

            alert("You hit a mine YOU LOOSE!"); // tells the user they lost
            let restart = prompt("type R to restart or E to exit");
            if (restart.toUpperCase() === "R") {
                startGame(); // restart the game loop for the user to play again 
            } else {
                alert("Thanks for playing!");
                return (gameLoop = false); // turns off the game loop and stops the program
            }
        }
    }

</script>


// SECTION Requirement 7. The program must end the game when all non-mine cells are uncovered. ------------------------------------


The "checkWinConditions" function takes in the "gridObj" parameter, it uses two nested "for" loops again to access the rows and column indexes of the "gridObj". It then checks if the tile is opened and is not a tile containing a mine, and then updates the "tilesOpened" variable, if that tile is a mine we update the "totalMineCount", the number of mines assigned is static so I didn't need to add this part in as I could of parsed the "numberOfMines" global variable, but I thought this method was just as easy and allows for changing requirements and potentially adding in a level feature without have to need the use of a global variable. The next piece of code calculates the "tileCount", by multiplying the length of the rows by the length of the columns, when then calculate the "tilesLeft", which is the "tileCount" minus the "totalMineCount" gives us total amount of cells available cells to open on the grid. "if" the "tilesOpened" is strictly equal to "tilesLeft", then then use the same for loop in the "checkLossConditions" to reveal all mines and display the grid. Lastly the program tells the user they've won, and allows them the option to restart the game.

<script>

    function checkWinConditions(gridObj) {
        let numRows = gridObj.length // length of rows
        let numCols = gridObj[0].length // length of columns

        let tilesOpened = 0; // tells us how many cells the user has opened
        let totalMineCount = 0; // count the total on mines on the board


        // calculate tilesOpened and tilesLeft inside the loop
        for (let i = 0; i < numRows; i++) {
            // loop though till number of rows

            for (let j = 0; j < numCols; j++) {
                // loop though till number of columns

                const tile = gridObj[i][j]; 
                // access the properties from every tile

                if (tile.visibility === "open" && !tile.isMine) {
                    // if the tile had been opened and that tile is not a mine

                    tilesOpened++; // getting the number of tiles opened
                } else if (tile.isMine) {
                    totalMineCount++; // getting the number of mines
                    // since the number of mines is static we don't really need to do this since we know that number
                    // I thought method just as easy as passing in the value
                }
            }
        }

        let tileCount = gridObj.length * gridObj[0].length; // total number of tiles
        let tilesLeft = tileCount - totalMineCount; 
        // total number of tiles - totalMineCount gives us total amount of cells available cells to open on the grid

        if (tilesOpened === tilesLeft) {
            //if the users opened tiles is equal to the amount of available tiles to open 

            for (let i = 0; i < numRows; i++) {
                //loop through rows
                for (let j = 0; j < numCols; j++) {
                    // loop though columns

                    if (gridObj[i][j].isMine) { // display the mines to the user
                        gridObj[i][j].visibility = "mine";
                        gridObj[i][j].char = "*";
                    }
                }
            }
            displayGrid(gridObj) // show the updated board with mine locations

            alert("Congratulations You've WON!"); // tell the user they won 
            let restart = prompt("type R to restart or E to exit"); // ask them to restart 
            if (restart.toUpperCase() === "R") {
                startGame(); // start game if the choose to 
            } else {
                // if they choose to not play then end the game loop
                alert("Thanks for playing!");
                return (gameLoop = false);
            }
        }
    }

</script>